exit
@tests[x].class_attribute
@tests[x].class_attributes
@tests[x].attribute
@tests[x].attributes
@tests[x].class.superclass
@tests[x].class.superClass
@tests[x].superclass
@tests[x].superClass
@tests[x].class.class_attribute
@tests[x].class.methods.class_attribute
@tests[x].class.methods.class_attributes
@tests[x].class.methods
@tests[x].class
pp @tests[x].class_methods
pp @tests[x].ancestors
pp @tests[x].ancestor
pp @tests[x].members
pp @tests[x].title
pp @tests[x]
@tests[x].class
@tests[x].name
@tests[x]
x.name
x
y
@@logs
exit
@classes[:three]
@classes[:two]
@classes[:one]
@logs[:two]
@logs[:one]
@logs
exit
 @classes.each{|x, y| @logs[x]= []}
@logs ={}
@classes.each{|x, y| @logs[x]= []}
@classes
@classes = {one: AutoSeed.method(:generate), two: AutoSeed2.method(:generate),three: AutoSeed3.method(:generate)}
@classes
exit
@logs
@classes.each{|x, y| @logs[x]= []}
@logs
@classes.each{|x, y| @logs[x]}
@logs
@logs = {}
@logs
@logger
@classes.each{|x, y| puts x}
@classes.each{|key, value| puts key}
@classes.each { |x, y| x.key}
@classes.each { |x, y| x}
@classes[:one].each { |x, y| x}
@classes[:one]
@classes.each{|x,y| @logs.merge( x.first: [])}
@logs
@logs[:three]
@logs[:two]
@logs[:one]
@logs.second
@logs.first
@logs
@classes.each{|x,y| @logs.merge( x: [])}
@classes.each{|x,y| @logs << x => []}
@logs << @classes.each{|x, y| {x => []}}
@logs[:one]
@logs['one']
@logs[:first]
@logs[:second]
@logs.second
@logs.first
@logs = @classes.each{|x, y| {x => []}}
@logs = @classes.each{|x, y| x => []}
@classes.map{|x, _| puts x.is_a? Symbol}
@classes.map{|x, _| puts x.to_sym}
@classes.map{|x, _| puts x}
@classes
@classes.map{|x| puts x}
@classes
@logs[x] << 1
@logs[x] = []
@logs[x].nil?
@logs[x].is_a? Nil
@logs[x].is_a? Array
@logs[x].is_a? Hash
@logs[x] << 1
@logs[x]
x
@logs
exit
t
@@classes[:one][:log]
@@classes[:one].first
@@classes[:one]
@@class[:one]
