exit
reject_models
exit
reject_models
exit
reject_models.flatten
reject_models
exit
(reject_models.push(params['EXCLUDE'].split(','))).flatten
reject_models.flatten
reject_models
p
p = params['EXCLUDE'].split.flatten
params['EXCLUDE'].split.flatten
params['EXCLUDE'].split
params['EXCLUDE']
params
reject_models
exit
reject_models
exit
reject_models
exit
Post.last
result
exit
name
@logger[name]
exit
@logger[name]
message
name
exit
exitexit
exit
next
y.name
@tests[x]
test
next
y.name
y
next
exit
exi
previous
prev
next
t
test
next
@logger[the_class]
next
@tests[x]
@tests[x[
next
t
test
next
@logger[the_class]
next
@tests[x]
test
next
enxt
@logger[the_class]
exit
logger(
@logger[name]
name
y
x
@logger[name]
message
name
exit
tests[x].inspect
tests[x].name
tests[x].second
tests[x].first
tests[x]
tests.first.second.attribute
tests.first.second.attributes
tests.first.second.inspect
tests.first.second
tests.first
tests
exit
@tests[x].source_location.first
@tests[x].source_location
@tests[x].first
@tests[x]
x.first
x
b = @tests.first
@tests.first
@tests.first.all
@tests.first.second.inspect
@tests.first.second.first
@tests.first.second
@tests.first.first
@tests.first
@test.first
@test
exit
p caller
pp caller
caller
exit
@logger[name]
exit
@logger.key? name
@logger[blah]
@logger[name].nil?
@logger[name].exist?
@logger[name].exists?
@logger[name]
@logger
exit
logger(name)
logger
@logger[name]
name
exit
@logger[name].info(message)
@logger[name]
messages
name
exit
@logging.write_log("s", "blahblah")
@logging.logger("s")
@logging.logger
 @logging = SpeedLogger.new(folder: "benchmark")
 @logging = SpeedLogger.new("benchmark")
 @logging = SpeedLogger::SpeedLogger.new("benchmark")
SpeedLogger
load '../lib/SpeedLogger/speed_logger.rb'
File.exists? '../lib/SpeedLogger/speed_logger.rb'
Dir.exists? '../lib/SpeedLogger/speed_logger.rb'
Dir.exists? '../lib/SpeedLogger'
Dir.exists? '../lib/AutoSeed'
$dir
$path
Path
Dir
SpeedLogger
exit
args.first[:name]
args
exit
args.first[:folder]
args.first
args[:speed]
*args
args
args[:folder]
exit
args
args[:folder]
*args[:folder]
args.second.is_a? Hash
args.second.is_a? Array
args.second.is_a? String
args.second
args
:folder
folder
args[:folder.to_sym]
args[:folder]
args
exit
args[:check]
args
exit
args
args.first[:folder]
args.first[:test]
args["test"]
args[log]
args[log
args[check]
args[:speed]
args[:test]
args.second
args.first
args
exit
@tests
exit
@logs[:one].first.real
@logs[:one].first.first
@logs[:one].first
@logs[:one].all
@logs[:one]['real']
@logs[:one][@real]
@logs[:one].real
@logs[:one]
@logs.first.second['real']
@logs.first.second[real]
@logs.first.second[:real]
@logs.first.second.real
@logs.first.second
@logs.first.first
@logs.first
@logs
exit
@tests[x].class_attribute
@tests[x].class_attributes
@tests[x].attribute
@tests[x].attributes
@tests[x].class.superclass
@tests[x].class.superClass
@tests[x].superclass
@tests[x].superClass
@tests[x].class.class_attribute
@tests[x].class.methods.class_attribute
@tests[x].class.methods.class_attributes
@tests[x].class.methods
@tests[x].class
pp @tests[x].class_methods
pp @tests[x].ancestors
pp @tests[x].ancestor
pp @tests[x].members
pp @tests[x].title
pp @tests[x]
@tests[x].class
@tests[x].name
@tests[x]
x.name
x
y
@@logs
exit
@classes[:three]
@classes[:two]
@classes[:one]
@logs[:two]
@logs[:one]
@logs
exit
 @classes.each{|x, y| @logs[x]= []}
@logs ={}
@classes.each{|x, y| @logs[x]= []}
@classes
@classes = {one: AutoSeed.method(:generate), two: AutoSeed2.method(:generate),three: AutoSeed3.method(:generate)}
@classes
exit
@logs
@classes.each{|x, y| @logs[x]= []}
@logs
@classes.each{|x, y| @logs[x]}
@logs
@logs = {}
@logs
@logger
@classes.each{|x, y| puts x}
